# 05 后端数据验证

上一章我们介绍了API的实现，我们列举了一个查询Chef列表的接口的实现，支持模糊查询、分页、排序。

如果我们实现一个插入或更新数据的接口，我们经常会有一个数据验证，例如Chef的姓名、用户名、密码不能为空，甚至会限制字段的长度。

通常我们会在前端Form里面加上这些验证，那后端还需要添加这些验证吗？

试想我们访问接口的方式有哪些？是不是只有前端UI界面？答案当然是否定的。通常我们会给前端或者客户提供接口文档，可以是swagger也可以是网页或Word类型的文档。

我们发送请求也不一定就需要一个UI，我们可以通过编程或工具很多方式来访问一个请求。所以后端的数据验证还是很有必要的。

## 5.1 zod数据验证库

这里同样没有为什么是zod的问题，Cursor帮我生成代码的时候就是用的zod。我们以后可以尝试其他的数据验证库。

安装zod库
```
PS D:\CodeSpace\next\dish-ms> npm i zod -S

up to date in 829ms

136 packages are looking for funding
  run `npm fund` for details
```

## 5.2 zod 验证规则

这部分我们可以查询zod的文档快速学习以下验证规则如何编写，下面是创建Chef的验证规则，我们定义了name和username都是必填（最少长度1）且不超过255个字符，password是至少6个字符且不超过255个字符。
前面我们已经提到我们创建了/lib目录存放这些公共的资源，我可以在/lib下创建一个validations.ts文件来存放这些验证模式（Schema）。

```
import { z } from 'zod'

// Chef schemas
export const createChefSchema = z.object({
  name: z.string().min(1, 'Chef name is required').max(255, 'Chef name is too long'),
  username: z.string().min(1, 'Username is required').max(255, 'Username is too long'),
  password: z.string().min(6, 'Password must be at least 6 characters').max(255, 'Password is too long'),
})
```

## 5.3 在接口中应用zod验证

```
/**
 * POST /api/chefs
 * 
 * Create a new chef
 * 
 * Request body:
 * {
 *   "name": "Chef John"
 *   "username": "ChefJohn1",
 *   "password": "123456"
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const validatedData = createChefSchema.parse(body)

    // Check if chef with same username already exists
    const existingChef = await prisma.chef.findUnique({
      where: {
        username: validatedData.username,
      },
      select: { id: true },
    })

    if (existingChef) {
      throw new ConflictError(`A chef with the username "${validatedData.username}" already exists`)
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(validatedData.password, 10)

    const chef = await prisma.chef.create({
      data: {
        name: validatedData.name,
        username: validatedData.username,
        password: hashedPassword,
      },
    })

    return NextResponse.json(
      {
        success: true,
        data: {
          id: chef.id,
          name: chef.name,
          username: chef.username,
          createdAt: chef.createdAt,
          updatedAt: chef.updatedAt,
        },
        message: 'Chef created successfully',
      },
      { status: 201 }
    )
  } catch (error) {
    if (error instanceof ValidationError) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: error.code,
            message: error.message,
            details: error.details,
          },
        },
        { status: error.statusCode }
      )
    }

    if (error && typeof error === 'object' && 'issues' in error) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Request data validation failed',
            details: error.issues,
          },
        },
        { status: 400 }
      )
    }

    if (error instanceof AppError) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: error.code || 'APP_ERROR',
            message: error.message,
          },
        },
        { status: error.statusCode }
      )
    }

    console.error('Unexpected error:', error)
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Internal server error',
        },
      },
      { status: 500 }
    )
  }
}
```

这里我们调用了`const validatedData = createChefSchema.parse(body)`来进行数据验证。

如果验证失败会抛出异常：
```
    if (error && typeof error === 'object' && 'issues' in error) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Request data validation failed',
            details: error.issues,
          },
        },
        { status: 400 }
      )
    }
```

因为异常有很多中，Cursor生成的代码显示如果error对象中包含'issues'属性就是数据验证失败，但是我用console.log打印error却没有展示这个属性。

通过翻阅文档得知这个异常的类型是ZodError，但是我直接跳转到这个接口的定义并没有找到issues的属性，到时有一个addIssues方法。

后续可以查看源码或其特资料再深入了解以下，因为就凭它含有一个issues属性就认定为数据验证错误是不靠谱的。